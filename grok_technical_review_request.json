{
  "messages": [
    {
      "role": "system", 
      "content": "You are a senior web performance engineer and technical architect with 15+ years of experience in React/Vite optimization, Core Web Vitals, and modern performance patterns. You specialize in code review for production-ready implementations and have deep expertise in identifying technical risks, implementation challenges, and architectural improvements. Please provide expert-level technical analysis with specific code-level recommendations."
    },
    {
      "role": "user",
      "content": "Please conduct a comprehensive expert code review of this Ultra-Detailed Technical Implementation PRD for DHM Guide Website performance optimization. I need your deep technical analysis on:\n\n**1. CODE QUALITY & ARCHITECTURE**\n- Are the React/Vite implementations technically sound and production-ready?\n- Do the code patterns follow modern best practices?\n- Are there any architectural flaws or anti-patterns?\n\n**2. PERFORMANCE IMPLEMENTATION ACCURACY**\n- Will the LCP optimization code actually achieve <2s target?\n- Is the Critical CSS implementation strategy effective?\n- Are the DOM operations properly optimized to prevent layout thrashing?\n- Will the Partytown GTM setup provide the projected performance gains?\n\n**3. TECHNICAL RISK ASSESSMENT**\n- What implementation challenges should be expected?\n- Are there potential browser compatibility issues?\n- What could go wrong during deployment?\n- Are the fallback strategies sufficient?\n\n**4. CODE COMPLETENESS & IMPLEMENTATION VARIANCE**\n- Are the code examples complete enough for direct implementation?\n- What additional code might developers need to write?\n- Are there any missing dependencies or configuration details?\n\n**5. MODERN PERFORMANCE PATTERNS (2025)**\n- Does the INP optimization align with latest Core Web Vitals standards?\n- Are the Speculation Rules and Priority Hints implemented correctly?\n- Is the Service Worker strategy optimal for this use case?\n\n**6. SCALING & MAINTENANCE CONSIDERATIONS**\n- Will this code scale with the application growth?\n- Are the monitoring systems comprehensive enough?\n- How maintainable is this implementation?\n\n**SPECIFIC TECHNICAL IMPLEMENTATIONS TO REVIEW:**\n\n```jsx\n// OptimizedImage Component\nconst OptimizedImage = ({ baseName, alt, sizes, priority, width, height }) => {\n  const [devicePixelRatio, setDevicePixelRatio] = useState(1);\n  \n  useEffect(() => {\n    setDevicePixelRatio(window.devicePixelRatio || 1);\n  }, []);\n\n  const generateSrcSet = (format = 'webp') => {\n    return imageVariants.map(width => `/images/${baseName}-${width}w.${format} ${width}w`).join(', ');\n  };\n\n  const getOptimalSrc = () => {\n    const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : 1024;\n    const targetWidth = viewportWidth <= 1023 ? viewportWidth - 32 : 600;\n    const requiredWidth = targetWidth * devicePixelRatio;\n    const optimalVariant = imageVariants.find(variant => variant >= requiredWidth) || 1536;\n    return `/images/${baseName}-${optimalVariant}w.webp`;\n  };\n```\n\n```javascript\n// PerformantDOMOperations Class\nclass PerformantDOMOperations {\n  constructor() {\n    this.readQueue = [];\n    this.writeQueue = [];\n    this.scheduled = false;\n  }\n\n  scheduleFlush() {\n    if (this.scheduled) return;\n    this.scheduled = true;\n\n    requestAnimationFrame(() => {\n      const readResults = this.readQueue.map(callback => callback());\n      this.readQueue = [];\n      this.writeQueue.forEach((callback, index) => {\n        callback(readResults[index]);\n      });\n      this.writeQueue = [];\n      this.scheduled = false;\n    });\n  }\n```\n\n```javascript\n// INP Optimization Implementation\nclass INPOptimizer {\n  async processQueue() {\n    if (this.isProcessing) return;\n    this.isProcessing = true;\n\n    while (this.taskQueue.length > 0) {\n      this.taskQueue.sort((a, b) => {\n        const priorities = { 'user-blocking': 3, 'user-visible': 2, 'background': 1 };\n        return (priorities[b.priority] || 1) - (priorities[a.priority] || 1);\n      });\n\n      const { task, resolve } = this.taskQueue.shift();\n      \n      if ('scheduler' in window && 'postTask' in scheduler) {\n        const result = await scheduler.postTask(task, { priority: this.getSchedulerPriority(priority) });\n        resolve(result);\n      }\n    }\n  }\n```\n\n```javascript\n// Partytown GTM Configuration\nconst partytownConfig = {\n  forward: ['gtag', 'dataLayer.push'],\n  debug: process.env.NODE_ENV === 'development',\n  atomics: true,\n  resolveUrl(url) {\n    if (url.hostname === 'www.googletagmanager.com') {\n      const proxyUrl = new URL('/proxy/gtm', location.origin);\n      proxyUrl.searchParams.append('url', url.href);\n      return proxyUrl;\n    }\n    return url;\n  }\n};\n```\n\n**PERFORMANCE TARGETS TO VALIDATE:**\n- LCP: 4.2s → 1.9s (55% improvement)\n- INP: 180ms → 65ms (64% improvement)\n- CLS: 0.28 → 0.04 (86% improvement)\n- Bundle: 86KB unused → 18KB unused (79% improvement)\n\n**CRITICAL QUESTIONS:**\n1. Will these implementations actually achieve the projected performance improvements?\n2. Are there any critical technical flaws that could cause production issues?\n3. What's missing from this implementation that could cause deployment failures?\n4. How would you improve this code for better performance or maintainability?\n5. Are the monitoring and rollback strategies sufficient for a production deployment?\n\nPlease provide a detailed technical assessment with specific code recommendations, potential issues, and implementation improvements. Focus on production readiness and actual performance impact."
    }
  ],
  "model": "grok-4",
  "temperature": 0.1
}